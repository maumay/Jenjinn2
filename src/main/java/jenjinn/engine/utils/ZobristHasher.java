/**
 *
 */
package jenjinn.engine.utils;

import java.util.Arrays;
import java.util.List;
import java.util.Random;

import jenjinn.engine.ChessPieces;
import jenjinn.engine.bitboards.BitboardIterator;
import jenjinn.engine.boardstate.CastlingStatus;
import jenjinn.engine.enums.BoardSquare;
import jenjinn.engine.enums.CastleZone;
import jenjinn.engine.enums.ChessPiece;
import jenjinn.engine.enums.Side;
import xawd.jflow.iterators.construction.IterRange;
import xawd.jflow.iterators.construction.Iterate;

/**
 * @author ThomasB
 *
 */
public final class ZobristHasher
{
	private final List<long[]> boardSquareFeatures;
	private final long[] castleRightsFeatures;
	private final long[] enpassantFileFeatures;
	private final long blackToMoveFeature;

	public ZobristHasher(final Random numberGenerator)
	{
		boardSquareFeatures = BoardSquare.iterateAll().map(x -> randomArray(12, numberGenerator)).toImmutableList();
		castleRightsFeatures = randomArray(4, numberGenerator);
		enpassantFileFeatures = randomArray(8, numberGenerator);
		blackToMoveFeature = numberGenerator.nextLong();
	}

	private long[] randomArray(final int length, final Random numberGenerator)
	{
		return IterRange.to(length).mapToLong(i -> numberGenerator.nextLong()).toArray();
	}

	public long getSquarePieceFeature(final BoardSquare square, final ChessPiece piece)
	{
		return boardSquareFeatures.get(square.ordinal())[piece.ordinal()];
	}

	public long getCastleRightsFeature(final CastleZone zone)
	{
		return castleRightsFeatures[zone.ordinal()];
	}

	public long getEnpassantFileFeature(final BoardSquare enPassantSquare)
	{
		return enpassantFileFeatures[enPassantSquare.ordinal() % 8];
	}

	public long getBlackToMoveFeature()
	{
		return blackToMoveFeature;
	}

	public long hashPieceLocations(final long[] pieceLocations)
	{
		if (pieceLocations.length != 12) {
			throw new IllegalArgumentException();
		}
		long hash = 0L;
		for (final ChessPiece piece : ChessPieces.all()) {
			hash ^= BitboardIterator.from(pieceLocations[piece.ordinal()])
					.mapToLong(loc -> getSquarePieceFeature(loc, piece))
					.reduce(0L, (a, b) -> a ^ b);
		}
		return hash;
	}

	public long hashNonPieceFeatures(final Side activeSide, final BoardSquare enpassantSquare, final CastlingStatus castlingStatus)
	{
		long hash = activeSide.isWhite()? 0L : getBlackToMoveFeature();
		hash ^= enpassantSquare == null? 0L : getEnpassantFileFeature(enpassantSquare);
		hash ^= Iterate.over(castlingStatus.getCastlingRights()).mapToLong(this::getCastleRightsFeature).reduce(0L, (a, b) -> a ^ b);
		return hash;
	}

	/*
	 * Generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (blackToMoveFeature ^ (blackToMoveFeature >>> 32));
		result = prime * result + ((boardSquareFeatures == null) ? 0 : boardSquareFeatures.hashCode());
		result = prime * result + Arrays.hashCode(castleRightsFeatures);
		result = prime * result + Arrays.hashCode(enpassantFileFeatures);
		return result;
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		final ZobristHasher other = (ZobristHasher) obj;
		if (blackToMoveFeature != other.blackToMoveFeature)
			return false;
		if (boardSquareFeatures == null) {
			if (other.boardSquareFeatures != null)
				return false;
		} else if (IterRange.to(12).anyMatch(i -> !Arrays.equals(boardSquareFeatures.get(i), other.boardSquareFeatures.get(i))))
			return false;
		if (!Arrays.equals(castleRightsFeatures, other.castleRightsFeatures))
			return false;
		if (!Arrays.equals(enpassantFileFeatures, other.enpassantFileFeatures))
			return false;
		return true;
	}
}
