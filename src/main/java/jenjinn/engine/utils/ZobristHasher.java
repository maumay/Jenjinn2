/**
 *
 */
package jenjinn.engine.utils;

import static jenjinn.engine.bitboards.BitboardUtils.getSetBitIndices;
import static xawd.jflow.utilities.MapUtil.longMap;

import java.util.Arrays;
import java.util.List;
import java.util.Random;

import jenjinn.engine.ChessPieces;
import jenjinn.engine.boardstate.BoardState;
import jenjinn.engine.enums.BoardSquare;
import jenjinn.engine.enums.CastleZone;
import jenjinn.engine.enums.ChessPiece;
import xawd.jflow.iterators.construction.IterRange;
import xawd.jflow.iterators.construction.Iterate;

/**
 * @author ThomasB
 *
 */
public final class ZobristHasher
{
	private final List<long[]> boardSquareFeatures;
	private final long[] castleRightsFeatures;
	private final long[] enpassantFileFeatures;
	private final long blackToMoveFeature;

	public ZobristHasher(final Random numberGenerator)
	{
		boardSquareFeatures = BoardSquare.iterateAll().map(x -> randomArray(12, numberGenerator)).toImmutableList();
		castleRightsFeatures = randomArray(4, numberGenerator);
		enpassantFileFeatures = randomArray(8, numberGenerator);
		blackToMoveFeature = numberGenerator.nextLong();
	}

	private long[] randomArray(final int length, final Random numberGenerator)
	{
		return IterRange.to(length).mapToLong(i -> numberGenerator.nextLong()).toArray();
	}

	public long getSquarePieceFeature(final BoardSquare square, final ChessPiece piece)
	{
		return boardSquareFeatures.get(square.ordinal())[piece.ordinal()];
	}

	public long getCastleRightsFeature(final CastleZone zone)
	{
		return castleRightsFeatures[zone.ordinal()];
	}

	public long getEnpassantFileFeature(final BoardSquare enPassantSquare)
	{
		return enpassantFileFeatures[enPassantSquare.ordinal() % 8];
	}

	public long getBlackToMoveFeature()
	{
		return blackToMoveFeature;
	}

	public long hashBoardState(BoardState state)
	{
		long hash = state.getEnPassantSquare() == null ? 0L : getEnpassantFileFeature(state.getEnPassantSquare());
		hash ^= state.getActiveSide().isWhite() ? 0L : getBlackToMoveFeature();
		hash ^= Iterate.over(state.getCastlingStatus().getCastlingRights())
				.mapToLong(this::getCastleRightsFeature)
				.reduce(0L, (a, b) -> a ^ b);
		for (final ChessPiece p : ChessPieces.all()) {
			final int[] locs = getSetBitIndices(state.getPieceLocations().locationsOf(p));
			final long[] features = longMap(loc -> getSquarePieceFeature(BoardSquare.of(loc), p), locs);
			hash ^= Iterate.over(features).reduce(0L, (a, b) -> a ^ b);
		}
		return hash;
	}

	/*
	 * Generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (blackToMoveFeature ^ (blackToMoveFeature >>> 32));
		result = prime * result + ((boardSquareFeatures == null) ? 0 : boardSquareFeatures.hashCode());
		result = prime * result + Arrays.hashCode(castleRightsFeatures);
		result = prime * result + Arrays.hashCode(enpassantFileFeatures);
		return result;
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		final ZobristHasher other = (ZobristHasher) obj;
		if (blackToMoveFeature != other.blackToMoveFeature)
			return false;
		if (boardSquareFeatures == null) {
			if (other.boardSquareFeatures != null)
				return false;
		} else if (!boardSquareFeatures.equals(other.boardSquareFeatures))
			return false;
		if (!Arrays.equals(castleRightsFeatures, other.castleRightsFeatures))
			return false;
		if (!Arrays.equals(enpassantFileFeatures, other.enpassantFileFeatures))
			return false;
		return true;
	}
}
